# Vue2 总结

## 响应式原理

### 数据劫持

#### 对象的数据劫持

Vue 在初始化时，会遍历 data 中的所有属性，通过 `Object.defineProperty` 方法定义属性的 `getter` 和 `setter`。
并将属性代理到实例上。当属性被读取时会触发 `getter` 方法，属性被赋值时会触发 `setter` 方法，从而实现数据劫持。

#### 数组的数据劫持

由于`Object.defineProperty`的局限性，数组数据劫持是通过重写 7 个可以改变数组本身的方法实现的。

### 创建依赖

在 vue 中依赖就是指 `watcher` 实例，一共有三种，分别是`渲染 watcher`、`计算属性 watcher`、`用户自定义 watcher`。

### 依赖收集

vue 初始化时会为对象中的每个实例创建一个 `Dep` 实例用于保存该属性的依赖，当 `watcher` 中的 `getter` 函数读取 `data` 中的某个属性出发属性的 `getter` 函数时，调用 `Dep` 实例中的 `depend` 方法对该依赖进行收集。

### 依赖更新

当对象的 `setter` 函数或者调用了 7 个改变数组本身的方法，会通过 `Dep` 实例中的 `notify` 方法通知依赖进行更新(再次触发 `getter`,计算属性 watcher 则会根据 dirty 值判断是否触发)。

## 模板编译

### 主要流程

解析模板 -> 生成 ast 语法树 -> 生成 render 函数

### 解析模板生成 ast 主要原理

主要思想：匹配一个标签删除一个标签，解析结束的标志为 `html===''`

#### 判断`<`位置，如果为 0 则是标签开始位置或者标签结束位置。

- 如果是标签开始位置，通过正则表达式获取标签中的属性和标签名，并将当前标签放入栈中，直到匹配开始标签的结束
  > 注：单标签节点不会被放入栈中
- 匹配到结束标签，则将栈中的标签出栈，并建立相应父子关系

#### 如果`<`位置大于 0，则是文本结束位置

- 解析当前文本，并将当前栈中最后一个标签节点作为自己的父节点

## nextTick

## computed 实现原理

Vue 在初始化时，会为每个计算属性创建一个计算属性 watcher，并将这些 watcher 挂载到实例上。通过传入 lazy 选项控制当前 wathcer 是计算属性 watcher，将计算属性的 getter 作为 watcher 的 getter，计算属性初始不会立即执行，属性被引用时才会执行。watcher 内部通过 dirty 判断需不需要执行 getter，不需要执行则直接返回原来的 value，从而达到缓存的效果。

> 1.计算属性默认不会立即执行 2.计算属性依赖计算属性 watcher 3.通过 dirty 判断 getter 函数需不需要执行

## watch 实现原理

## diff 算法
