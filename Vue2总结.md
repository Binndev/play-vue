# Vue2 总结

## 响应式原理

### 数据劫持

#### 对象的数据劫持

Vue 在初始化时，会遍历 data 中的所有属性，通过 `Object.defineProperty` 方法定义属性的 `getter` 和 `setter`。
并将属性代理到实例上。当属性被读取时会触发 `getter` 方法，属性被赋值时会触发 `setter` 方法，从而实现数据劫持。

#### 数组的数据劫持

由于`Object.defineProperty`的局限性，数组数据劫持是通过重写 7 个可以改变数组本身的方法实现的。

### 创建依赖

在 vue 中依赖就是指 `watcher` 实例，一共有三种，分别是`渲染 watcher`、`计算属性 watcher`、`用户自定义 watcher`。

### 依赖收集

vue 初始化时会为对象中的每个实例创建一个 `Dep` 实例用于保存该属性的依赖，当 `watcher` 中的 `getter` 函数读取 `data` 中的某个属性出发属性的 `getter` 函数时，调用 `Dep` 实例中的 `depend` 方法对该依赖进行收集。

### 依赖更新

当对象的 `setter` 函数或者调用了 7 个改变数组本身的方法，会通过 `Dep` 实例中的 `notify` 方法通知依赖进行更新(再次触发 `getter`,计算属性 watcher 则会根据 dirty 值判断是否触发)。

## 模板编译

### 主要流程

解析模板 -> 生成 ast 语法树 -> 生成 render 函数

### 解析模板生成 ast 主要原理

主要思想：匹配一个标签删除一个标签，解析结束的标志为 `html===''`

#### 判断`<`位置，如果为 0 则是标签开始位置或者标签结束位置。

- 如果是标签开始位置，通过正则表达式获取标签中的属性和标签名，并将当前标签放入栈中，直到匹配开始标签的结束
  > 注：单标签节点不会被放入栈中
- 匹配到结束标签，则将栈中的标签出栈，并建立相应父子关系

#### 如果`<`位置大于 0，则是文本结束位置

- 解析当前文本，并将当前栈中最后一个标签节点作为自己的父节点

## nextTick

### 异步更新 dom

由于渲染 `watcher` 中可能会存在多个属性，多个属性可能会同时被修改，`watcher` 中的 `update` 方法会被触发多次。为了提升性能，vue 采用异步更新，且同一个 `watcher`，`update` 方法只执行一次。

### 实现原理

内部维护一个异步任务队列，每次调用 nextTick，会将回调函数放入异步任务队列中，通过异步函数调用队列中的函数。

> 异步函数方案降级: `promise` -> `MutationObserver` -> `setImmediate` -> `setTimeout`

## computed 实现原理

Vue 在初始化时，会为每个计算属性创建一个计算属性 `watcher`，并将这些 `watcher` 挂载到实例上。通过传入 `lazy` 选项控制当前 `wathcer` 是`计算属性 watcher`，将计算属性的 `getter` 作为 `watcher` 的 `getter`，计算属性初始不会立即执行，属性被引用时才会执行。`watcher` 内部通过 `dirty` 判断需不需要执行 `getter`，不需要执行则直接返回原来的 `value`，从而达到缓存的效果。

> 1.计算属性默认不会立即执行 2.计算属性依赖计算属性 watcher 3.通过 dirty 判断 getter 函数需不需要执行

## watch 实现原理

Vue 初始化时为每个 `watch` 创建一个 `wathcer` 实例，通过传入 `user = true` 来标识当前 `watcher` 为用户`自定义 watcher`。当依赖的属性更新时，触发`watcher`实例的`update`方法，如果是用户自定义`watcher`会将旧值和新值传入用户的`callback`中。

## diff 算法

1. 两个节点不是同一个节点则直接用新节点替换旧节点
2. 新节点和旧节点都是文本节点则将新节点文本替换旧节点文本
3. 新旧节点都是节点元素，则比较子孙节点

   - 新节点有子孙节点，旧节点没有子孙节点，将新节点子孙节点插入旧节点中。
   - 新节点没有子孙节点，旧节点有子孙节点，删除旧节点中的子孙节点。
   - 双方都有子孙节点，进行双端对比

4. 双端对比

   - 将新旧子节点数组首尾各加两个指针，进行两两判断

   - 新旧节点头部相同，则执行更新节点操作，然后各自头部指针+1
   - 新旧节点尾部相同，执行更新节点操作，然后各自尾部指针-1
   - 如果新节点数组的尾部和旧节点的头部相同，则将旧节点的头部移动到旧节点的尾部，然后更新节点，且旧节点头部+1，新节点尾部-1
   - 如果新节点数组的头部和旧节点数组尾部相同，则将旧节点数组的尾部移到旧节点数组的头部，然后更新节点，且新节点尾部-1，旧节点头部+1
   - 如果以上四种都未命中，则以旧节点的 key 为属性，以旧节点索引为值建立 map，遍历新节点，通过新节点的 key 和 map 查找旧节点中是否存在和新节点相同的节点，存在则更新节点并移动节点位置，如果不存在则新建节点，并插入旧节点头部。
   - 循环结束后比较新旧节点首尾指针
     - 新节点首部小于新节点尾部，则将两者之间的节点插入元素中。
     - 旧节点首部小于旧节点尾部，则将两者之间节点删除
